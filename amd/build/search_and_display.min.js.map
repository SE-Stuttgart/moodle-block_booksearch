{"version":3,"file":"search_and_display.min.js","sources":["../src/search_and_display.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Block core and UI\n *\n * @module     block_booksearch/search_and_display\n * @copyright  2024 University of Stuttgart <kasra.habib@iste.uni-stuttgart.de>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * String label 'Chapter' in the current language.\n */\nlet chapterLabel = 'Chapter';\n\n/**\n * Sets up the event listener for search input changes.\n * @param {string} label String label 'Chapter' in the current language.\n */\nexport function init(label) {\n    chapterLabel = label;\n    const inputElement = document.getElementById('bs-search-input');\n    inputElement.addEventListener('input', handleSearchInputChange);\n}\n\n/**\n * Function to handle search term input event\n * @param {*} event The input event catched by the listener.\n */\nfunction handleSearchInputChange(event) {\n    const searchTerm = event.target.value;\n    const searchTermLabel = document.getElementById('bs-search-term-label').value;\n    const courseContent = JSON.parse(atob(document.getElementById('bs-json-course-content').value));\n    const contextLength = 5;\n\n    let searchResults = [];\n\n    // We search the content if we have a search term.\n    if (searchTerm) {\n        courseContent.forEach(section => getSectionResults(section, searchTerm, contextLength, searchResults));\n    }\n\n    // Update the inner HTML of the element with ID 'bs-search-term' to display the current search Term.\n    document.getElementById(\"bs-search-term\").innerHTML = searchTermLabel + searchTerm;\n\n    // Update the inner HTML of the element with ID 'bs-content' to display the results.\n    document.getElementById(\"bs-content\").innerHTML = getResultsUI(searchResults);\n}\n\n\n/**\n * Generates an HTML string to display search results for PDFs and their chapters.\n * @param {Object} searchResults - An object where keys are PDF names and values are objects of chapters.\n * @returns {string} An HTML string with headings for each PDF name and an unordered list of chapters, each with link and context.\n */\nfunction getResultsUI(searchResults) {\n    // Initialize an empty string to build the HTML display\n    let display = '';\n\n    // Iterate over each PDF name in the search results\n    for (var pdfName in searchResults) {\n        // Add the PDF name as a heading\n        display += '<h4>' + pdfName + '</h4>';\n        // Start an unordered list for the chapters\n        display += '<ul class=\"bs-content-element\">';\n        // Iterate over each chapter in the current PDF\n        for (var chapter in searchResults[pdfName]) {\n            // Add each chapter as a list item with a link and context\n            display += '<li>' +\n                '<a href=\"' + searchResults[pdfName][chapter].bookurl + '\">' +\n                chapterLabel + '-' + chapter +\n                '</a>: ' + searchResults[pdfName][chapter].context +\n                '</li>';\n        }\n        // Close the unordered list\n        display += '</ul>';\n    }\n\n    return display;\n}\n\n\n/**\n * Processes a section of content to extract and format search results based on a search term and context length.\n * @param {Object} section - An object representing a section of content with properties `content` (text) and `filename`.\n * @param {string} searchTerm - The term to search for within the section content.\n * @param {number} contextLength - The number of words to include before and after each occurrence of the search term.\n * @param {Object} searchResults - An object to store the search results, with filenames as keys and sections as values.\n */\nfunction getSectionResults(section, searchTerm, contextLength, searchResults) {\n    // Get the section content.\n    const content = section.content.toLowerCase();\n    const term = searchTerm.toLowerCase();\n\n    // Check if the search term is present in the content.\n    if (!content.includes(term)) {\n        return;\n    }\n\n    // Get all term occurances in the content with index.\n    const occuranceIndexes = getTermOccurances(content, term);\n\n    // Expannd and combine the occurances into ranges with start and end index.\n    const occuranceRanges = expandOccuranceData(occuranceIndexes, term.length);\n\n    // Get all words in content with starting index.\n    const words = splitTextWithIndices(content);\n\n    // Combine all words belonging to the same search result occurance to have the best context.\n    const contextWords = combineWordsInOccurrences(words, occuranceRanges);\n\n    // Get all occurance indexes for the contextWords array.\n    const contextSnippetIndexes = processContextWords(contextWords, contextLength);\n\n    // Combine all words within context size range of one search term occurance into one result. Discard unnecessary words.\n    const contextSnippets = createContextSnippets(contextWords, contextSnippetIndexes);\n\n    // Combine all Occurances into a single string.\n    const result = generateFinalResult(contextWords, contextSnippetIndexes, contextSnippets);\n\n    // Add result to the section object.\n    section.context = result;\n\n    // Create new file entry in results if it does not exist.\n    if (!(section.filename in searchResults)) {\n        searchResults[section.filename] = [];\n    }\n\n    // Set chapter entry as section or add section context to existing chapter entry.\n    if (!(section.page in searchResults[section.filename])) {\n        searchResults[section.filename][section.page] = section;\n    } else {\n        searchResults[section.filename][section.page].context += \" ... \" + section.context;\n    }\n}\n\n\n/**\n * Generates the final result string with context snippets and ellipses.\n * @param {Array<[boolean, number, string]>} contextWords - Array of combined words with starting indices.\n * @param {Array<[number, number]>} contextSnippetIndexes - Array of start and end indices for context snippets.\n * @param {Array<string>} contextSnippets - Array of context snippets as strings.\n * @returns {string} - Final result string with ellipses.\n */\nfunction generateFinalResult(contextWords, contextSnippetIndexes, contextSnippets) {\n    // Collapse context snippets into a single string separated by ' ... '.\n    let result = contextSnippets.join(' ... ');\n\n    // Add ellipses at the beginning if the first context snippet does not start at 0.\n    if (contextSnippetIndexes[0][0] > 0) {\n        result = '... ' + result;\n    }\n\n    // Add ellipses at the end if the last context snippet does not end at the last word.\n    if (contextSnippetIndexes[contextSnippetIndexes.length - 1][1] < contextWords.length - 1) {\n        result = result + ' ...';\n    }\n\n    return result;\n}\n\n\n/**\n * Creates context snippets from context words and snippet indexes.\n * @param {Array<[boolean, number, string]>} contextWords - Array of combined words with starting indices.\n * @param {Array<[number, number]>} contextSnippetIndexes - Array of start and end indices for context snippets.\n * @returns {Array<string>} - Array of context snippets as strings.\n */\nfunction createContextSnippets(contextWords, contextSnippetIndexes) {\n    const result = [];\n\n    for (let i = 0; i < contextSnippetIndexes.length; i++) {\n        const [start, end] = contextSnippetIndexes[i];\n        const words = [];\n\n        for (let index = start; index <= end; index++) {\n            words.push(contextWords[index][2]); // Get the word from the contextWords array.\n        }\n\n        result.push(words.join(' ')); // Collapse words into a single string.\n    }\n\n    return result;\n}\n\n\n/**\n * This function returns the start and end indexes for the context for each search term occurance.\n * @param {Array<[boolean, number, string]>} contextWords - Array of combined words with starting indices.\n * @param {number} contextLength - Number of words before and after each occurrence to include in the context.\n * @returns {Array<[number, number]>} - Array of start and end indices of occurrences.\n */\nfunction processContextWords(contextWords, contextLength) {\n    const occurrences = [];\n    let currentOccurrenceStart = -2 * contextLength;\n    let currentOccurrenceEnd = -2 * contextLength;\n\n    for (let i = 0; i < contextWords.length; i++) {\n        const [isOccurrence, index] = contextWords[i];\n\n        if (!isOccurrence) {\n            continue;\n        }\n\n        const start = Math.max(0, index - contextLength);\n        const end = Math.min(contextWords.length - 1, index + contextLength);\n\n        // IF the context of two occurances touch, they get combined.\n        if (currentOccurrenceEnd >= start - 1) {\n            currentOccurrenceEnd = end;\n            continue;\n        }\n\n        // The occurances are too far apart and get seperated.\n        occurrences.push([currentOccurrenceStart, currentOccurrenceEnd]);\n        currentOccurrenceStart = start;\n        currentOccurrenceEnd = end;\n    }\n\n    occurrences.push([currentOccurrenceStart, currentOccurrenceEnd]);\n    occurrences.shift(); // Remove the initial placeholder.\n\n    return occurrences;\n}\n\n\n/**\n * Combines words into one array element if they are in one occurrence.\n * @param {Array<[number, string]>} words - Array of pairs [starting index, word].\n * @param {Array<[number, number]>} occurrences - Array of pairs [start, end].\n * @returns {Array<[boolean, number, string]>} - Array of combined words with starting indices.\n */\nfunction combineWordsInOccurrences(words, occurrences) {\n    const result = [];\n    let currentOccurrenceIndex = 0;\n    let [currentOccurrenceStart, currentOccurrenceEnd] = occurrences.length > 0 ? occurrences[0] : [-1, -1];\n    let currentOccurrenceWords = [];\n    let resultIndexCounter = 0;\n\n    // Iterate over all words.\n    for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {\n        const [wordStart, word] = words[wordIndex];\n        const wordEnd = wordStart + word.length;\n\n        // No current occurrence, word added to result normally.\n        if (currentOccurrenceEnd === -1) {\n            result.push([false, resultIndexCounter++, word]);\n            continue;\n        }\n\n        // Current word is before the current occurrence, word added to result normally.\n        if (wordEnd < currentOccurrenceStart) {\n            result.push([false, resultIndexCounter++, word]);\n            continue;\n        }\n\n        // Current word is inside the current occurrence, word added to the combined word.\n        if (wordEnd >= currentOccurrenceStart && wordStart <= currentOccurrenceEnd) {\n            currentOccurrenceWords.push(word);\n            continue;\n        }\n\n        // Current word is after the current occurrence, the current occurance is completed, retry word.\n        if (wordStart > currentOccurrenceEnd) {\n            // Combine the words with occurance into one and add to result.\n            result.push([true, resultIndexCounter++, currentOccurrenceWords.join(' ')]);\n            currentOccurrenceWords = [];\n\n            // Move to the next occurrence.\n            currentOccurrenceIndex++;\n            if (currentOccurrenceIndex < occurrences.length) {\n                [currentOccurrenceStart, currentOccurrenceEnd] = occurrences[currentOccurrenceIndex];\n            } else {\n                [currentOccurrenceStart, currentOccurrenceEnd] = [-1, -1];\n            }\n\n            // Recheck the same word with the new current occurrence.\n            wordIndex--;\n        }\n    }\n\n    // Add the last occurrence words if any.\n    if (currentOccurrenceWords.length > 0) {\n        result.push([true, resultIndexCounter++, currentOccurrenceWords.join(' ')]);\n    }\n\n    return result;\n}\n\n\n/**\n * Splits the text into words and returns pairs of [starting index, word].\n * @param {string} text - The original text.\n * @returns {Array<[number, string]>} - Array of pairs [starting index, word].\n */\nfunction splitTextWithIndices(text) {\n    const words = [];\n    const regex = /\\S+/g; // Matches any non-whitespace sequence.\n\n    let match;\n    while ((match = regex.exec(text)) !== null) {\n        words.push([match.index, match[0]]);\n    }\n\n    return words;\n}\n\n\n/**\n * Transforms occurrences into pairs of start/end information.\n * @param {number[]} positions - Array of start positions.\n * @param {number} length - Length of each term.\n * @returns {number[][]} Array of pairs [start, end].\n */\nfunction expandOccuranceData(positions, length) {\n    if (positions.length === 0) {\n        return [];\n    }\n\n    const result = [];\n    let currentStart = positions[0];\n    let currentEnd = currentStart + length;\n\n    // In this for loop, positions[i] describes the next occurance.\n    for (let i = 1; i < positions.length; i++) {\n        if (currentEnd >= positions[i]) {\n            // If currentEnd overlaps with the next start position, merge them.\n            currentEnd = positions[i] + length;\n        } else {\n            // If no overlap, push the current start/end pair to the result.\n            result.push([currentStart, currentEnd]);\n            // Update currentStart and currentEnd to the new positions.\n            currentStart = positions[i];\n            currentEnd = currentStart + length;\n        }\n    }\n\n    // Push the last start/end pair to the result.\n    result.push([currentStart, currentEnd]);\n\n    return result;\n}\n\n\n/**\n * This Function returns a list of starting indexes for all occurances of the given term in the given content.\n * @param {string} content The text content to search in.\n * @param {string} term The search term to search for.\n * @returns Array of start indexes of the term occurances in the content.\n */\nfunction getTermOccurances(content, term) {\n    const occurances = [];\n    let startIndex = 0;\n    while ((startIndex = content.indexOf(term, startIndex)) !== -1) {\n        occurances.push(startIndex);\n        startIndex += 1;\n    }\n    return occurances;\n}"],"names":["label","chapterLabel","document","getElementById","addEventListener","handleSearchInputChange","event","searchTerm","target","value","searchTermLabel","courseContent","JSON","parse","atob","searchResults","forEach","section","contextLength","content","toLowerCase","term","includes","occuranceRanges","positions","length","result","currentStart","currentEnd","i","push","expandOccuranceData","occurances","startIndex","indexOf","getTermOccurances","contextWords","words","occurrences","currentOccurrenceIndex","currentOccurrenceStart","currentOccurrenceEnd","currentOccurrenceWords","resultIndexCounter","wordIndex","wordStart","word","wordEnd","join","combineWordsInOccurrences","text","regex","match","exec","index","splitTextWithIndices","contextSnippetIndexes","isOccurrence","start","Math","max","end","min","shift","processContextWords","contextSnippets","createContextSnippets","generateFinalResult","context","filename","page","getSectionResults","innerHTML","display","pdfName","chapter","bookurl","getResultsUI"],"mappings":"4JAgCqBA,OACjBC,aAAeD,MACME,SAASC,eAAe,mBAChCC,iBAAiB,QAASC;;;;;;;;IATvCJ,aAAe,mBAgBVI,wBAAwBC,aACvBC,WAAaD,MAAME,OAAOC,MAC1BC,gBAAkBR,SAASC,eAAe,wBAAwBM,MAClEE,cAAgBC,KAAKC,MAAMC,KAAKZ,SAASC,eAAe,0BAA0BM,YAGpFM,cAAgB,GAGhBR,YACAI,cAAcK,SAAQC,kBAkDHA,QAASV,WAAYW,cAAeH,qBAErDI,QAAUF,QAAQE,QAAQC,cAC1BC,KAAOd,WAAWa,kBAGnBD,QAAQG,SAASD,mBAQhBE,yBAmNmBC,UAAWC,WACX,IAArBD,UAAUC,aACH,SAGLC,OAAS,OACXC,aAAeH,UAAU,GACzBI,WAAaD,aAAeF,WAG3B,IAAII,EAAI,EAAGA,EAAIL,UAAUC,OAAQI,IAC9BD,YAAcJ,UAAUK,GAExBD,WAAaJ,UAAUK,GAAKJ,QAG5BC,OAAOI,KAAK,CAACH,aAAcC,aAE3BD,aAAeH,UAAUK,GACzBD,WAAaD,aAAeF,eAKpCC,OAAOI,KAAK,CAACH,aAAcC,aAEpBF,OA7OiBK,UAuPDZ,QAASE,YAC1BW,WAAa,OACfC,WAAa,QAC4C,KAArDA,WAAad,QAAQe,QAAQb,KAAMY,cACvCD,WAAWF,KAAKG,YAChBA,YAAc,SAEXD,WAjQkBG,CAAkBhB,QAASE,MAGUA,KAAKI,QAM7DW,sBA2HyBC,MAAOC,mBAChCZ,OAAS,OACXa,uBAAyB,GACxBC,uBAAwBC,sBAAwBH,YAAYb,OAAS,EAAIa,YAAY,GAAK,EAAE,GAAI,GACjGI,uBAAyB,GACzBC,mBAAqB,MAGpB,IAAIC,UAAY,EAAGA,UAAYP,MAAMZ,OAAQmB,YAAa,OACpDC,UAAWC,MAAQT,MAAMO,WAC1BG,QAAUF,UAAYC,KAAKrB,QAGH,IAA1BgB,qBAMAM,QAAUP,uBACVd,OAAOI,KAAK,EAAC,EAAOa,qBAAsBG,OAK1CC,SAAWP,wBAA0BK,WAAaJ,qBAClDC,uBAAuBZ,KAAKgB,MAK5BD,UAAYJ,uBAEZf,OAAOI,KAAK,EAAC,EAAMa,qBAAsBD,uBAAuBM,KAAK,OACrEN,uBAAyB,GAGzBH,yBACIA,uBAAyBD,YAAYb,QACpCe,uBAAwBC,sBAAwBH,YAAYC,yBAE5DC,uBAAwBC,sBAAwB,EAAE,GAAI,GAI3DG,aA/BAlB,OAAOI,KAAK,EAAC,EAAOa,qBAAsBG,OAoC9CJ,uBAAuBjB,OAAS,GAChCC,OAAOI,KAAK,EAAC,EAAMa,qBAAsBD,uBAAuBM,KAAK,cAGlEtB,OAjLcuB,UA0LKC,YACpBb,MAAQ,GACRc,MAAQ,WAEVC,WACkC,QAA9BA,MAAQD,MAAME,KAAKH,QACvBb,MAAMP,KAAK,CAACsB,MAAME,MAAOF,MAAM,YAG5Bf,MAtMOkB,CAAqBpC,SAGmBI,iBAGhDiC,+BAgFmBpB,aAAclB,qBACjCoB,YAAc,OAChBE,wBAA0B,EAAItB,cAC9BuB,sBAAwB,EAAIvB,kBAE3B,IAAIW,EAAI,EAAGA,EAAIO,aAAaX,OAAQI,IAAK,OACnC4B,aAAcH,OAASlB,aAAaP,OAEtC4B,4BAICC,MAAQC,KAAKC,IAAI,EAAGN,MAAQpC,eAC5B2C,IAAMF,KAAKG,IAAI1B,aAAaX,OAAS,EAAG6B,MAAQpC,eAGlDuB,sBAAwBiB,MAAQ,EAChCjB,qBAAuBoB,KAK3BvB,YAAYR,KAAK,CAACU,uBAAwBC,uBAC1CD,uBAAyBkB,MACzBjB,qBAAuBoB,YAG3BvB,YAAYR,KAAK,CAACU,uBAAwBC,uBAC1CH,YAAYyB,QAELzB,YA9GuB0B,CAAoB5B,aAAclB,eAG1D+C,yBAqDqB7B,aAAcoB,6BACnC9B,OAAS,OAEV,IAAIG,EAAI,EAAGA,EAAI2B,sBAAsB/B,OAAQI,IAAK,OAC5C6B,MAAOG,KAAOL,sBAAsB3B,GACrCQ,MAAQ,OAET,IAAIiB,MAAQI,MAAOJ,OAASO,IAAKP,QAClCjB,MAAMP,KAAKM,aAAakB,OAAO,IAGnC5B,OAAOI,KAAKO,MAAMW,KAAK,aAGpBtB,OAnEiBwC,CAAsB9B,aAAcoB,uBAGtD9B,gBA0BmBU,aAAcoB,sBAAuBS,qBAE1DvC,OAASuC,gBAAgBjB,KAAK,SAG9BQ,sBAAsB,GAAG,GAAK,IAC9B9B,OAAS,OAASA,QAIlB8B,sBAAsBA,sBAAsB/B,OAAS,GAAG,GAAKW,aAAaX,OAAS,IACnFC,QAAkB,eAGfA,OAxCQyC,CAAoB/B,aAAcoB,sBAAuBS,iBAGxEhD,QAAQmD,QAAU1C,OAGZT,QAAQoD,YAAYtD,gBACtBA,cAAcE,QAAQoD,UAAY,IAIhCpD,QAAQqD,QAAQvD,cAAcE,QAAQoD,UAGxCtD,cAAcE,QAAQoD,UAAUpD,QAAQqD,MAAMF,SAAW,QAAUnD,QAAQmD,QAF3ErD,cAAcE,QAAQoD,UAAUpD,QAAQqD,MAAQrD,QA3FfsD,CAAkBtD,QAASV,WAN1C,EAMqEQ,iBAI3Fb,SAASC,eAAe,kBAAkBqE,UAAY9D,gBAAkBH,WAGxEL,SAASC,eAAe,cAAcqE,mBASpBzD,mBAEd0D,QAAU,OAGT,IAAIC,WAAW3D,cAAe,KAM1B,IAAI4D,WAJTF,SAAW,OAASC,QAAU,QAE9BD,SAAW,kCAES1D,cAAc2D,SAE9BD,SAAW,gBACO1D,cAAc2D,SAASC,SAASC,QAAU,KACxD3E,aAAe,IAAM0E,QACrB,SAAW5D,cAAc2D,SAASC,SAASP,QAC3C,QAGRK,SAAW,eAGRA,QAhC2CI,CAAa9D"}