{"version":3,"file":"search_and_display.min.js","sources":["../src/search_and_display.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Block core and UI\n *\n * @module     block_booksearch/search_and_display\n * @copyright  2024 University of Stuttgart <kasra.habib@iste.uni-stuttgart.de>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * String label 'Chapter' in the current language.\n */\nlet chapterLabel = 'Chapter';\n\n/**\n * Sets up the event listener for search input changes.\n * @param {string} label String label 'Chapter' in the current language.\n */\nexport function init(label) {\n    chapterLabel = label;\n    const inputElement = document.getElementById('bs-search-input');\n    inputElement.addEventListener('input', handleSearchInputChange);\n}\n\n/**\n * Function to handle search term input event\n * @param {*} event The input event catched by the listener.\n */\nfunction handleSearchInputChange(event) {\n    const searchTerm = event.target.value;\n    const searchTermLabel = document.getElementById('bs-search-term-label').value;\n    const courseContent = JSON.parse(atob(document.getElementById('bs-json-course-content').value));\n    const contextLength = 5;\n\n    let searchResults = [];\n    // We search the content if we have a search term.\n    if (searchTerm) {\n        searchResults = getSearchResults(courseContent, searchTerm, contextLength);\n    }\n\n    // Update the inner HTML of the element with ID 'bs-search-term' to display the current search Term.\n    document.getElementById(\"bs-search-term\").innerHTML = searchTermLabel + searchTerm;\n\n    // Update the inner HTML of the element with ID 'bs-content' to display the results.\n    document.getElementById(\"bs-content\").innerHTML = getResultsUI(searchResults);\n}\n\n\n/**\n * Generates an HTML string to display search results for PDFs and their chapters.\n * @param {Object} searchResults - An object where keys are PDF names and values are objects of chapters.\n * @returns {string} An HTML string with headings for each PDF name and an unordered list of chapters, each with link and context.\n */\nfunction getResultsUI(searchResults) {\n    // Initialize an empty string to build the HTML display\n    let display = '';\n\n    // Iterate over each PDF name in the search results\n    for (var pdfName in searchResults) {\n        // Add the PDF name as a heading\n        display += '<h4>' + pdfName + '</h4>';\n        // Start an unordered list for the chapters\n        display += '<ul class=\"bs-content-element\">';\n        // Iterate over each chapter in the current PDF\n        for (var chapter in searchResults[pdfName]) {\n            // Add each chapter as a list item with a link and context\n            display += '<li>' +\n                '<a href=\"' + searchResults[pdfName][chapter].bookurl + '\">' +\n                chapterLabel + '-' + chapter +\n                '</a>: ' + searchResults[pdfName][chapter].context +\n                '</li>';\n        }\n        // Close the unordered list\n        display += '</ul>';\n    }\n\n    return display;\n}\n\n\n/**\n * Processes an array of content sections to extract and format search results based on a search term and context length.\n * @param {Array} courseContent Array of content sections, where each section is an object\n * with keys 'content', 'filename', and 'page'.\n * @param {string} searchTerm The term to search for within the content sections.\n * @param {number} contextLength The number of words to include before and after each occurrence of the search term.\n * @return {Object} The search results, with filenames as keys and sections as values.\n * [filename: {page: {section}}]\n */\nfunction getSearchResults(courseContent, searchTerm, contextLength) {\n    const results = {};\n\n    courseContent.forEach(section => {\n        // Get any search results with context from the section.\n        const context = getSectionSearchResultContext(section.content, searchTerm, contextLength);\n\n        // Add result to the section object.\n        section.context = context;\n\n        // Skip this section if there's no context (no result).\n        if (context.length < 1) {\n            return;\n        }\n\n        // Create new file entry in results if it does not exist.\n        if (!results.hasOwnProperty(section.filename)) {\n            results[section.filename] = {};\n        }\n\n        // Set chapter entry as section or add section context to existing chapter entry.\n        if (!results[section.filename].hasOwnProperty(section.page)) {\n            results[section.filename][section.page] = {\n                filename: section.filename,\n                url: section.url,\n                bookUrl: section.bookUrl,\n                context: section.context\n            };\n        } else {\n            // Append to existing context if the section already exists.\n            results[section.filename][section.page].context += section.context;\n        }\n    });\n\n    return results;\n}\n\n\n/**\n * Get a combined string of any found search term occurrences in the content with the surrounding words as context.\n * @param {string} content The text content to search in.\n * @param {string} searchTerm The term to search for in this content.\n * @param {number} contextLength The number of words on each side surrounding the found occurrence to be returned as context.\n * @return {string} Text snippets for each term occurrence with their context, combined as one.\n */\nfunction getSectionSearchResultContext(content, searchTerm, contextLength) {\n    const searchContent = content.toLowerCase();\n    searchTerm = searchTerm.toLowerCase();\n\n    // Check if the search term is present in the content.\n    if (searchContent.indexOf(searchTerm) === -1) {\n        return \"\";\n    }\n\n    // Get the text indexes of the term occurrences. Array of objects with 'start' and 'end' properties.\n    const occurrenceIndexes = findOccurrences(searchContent, searchTerm);\n\n    // Get the text as words and word starting indexes.\n    const [words, wordIndexes] = splitTextIntoWords(content);\n\n    // Get the word number positions of the context we want to return. Objects with 'start' and 'end' properties.\n    const contextPositions = getContextPositions(occurrenceIndexes, wordIndexes, contextLength);\n\n    // Get the combined string context.\n    const context = getContext(words, contextPositions);\n\n    return context;\n}\n\n\n/**\n * Searches for occurrences of a term in a given text and returns an array of occurrence objects.\n * Each occurrence object contains the start index (position in text) and the end index.\n * @param {string} text The text in which to search for the term.\n * @param {string} term The term to search for within the text.\n * @return {Array} An array of objects, each with 'start' and 'end' properties.\n */\nfunction findOccurrences(text, term) {\n    const occurrences = [];\n    const termLength = term.length;\n\n    // Use indexOf to find the occurrences of the term in the text.\n    let offset = 0;\n    let index;\n\n    while ((index = text.indexOf(term, offset)) !== -1) {\n        const occurrence = {\n            start: index,\n            end: index + termLength\n        };\n        occurrences.push(occurrence);\n        // Update the offset to search for the next occurrence.\n        offset = index + 1;\n    }\n\n    return occurrences;\n}\n\n\n/**\n * Splits the text into words and returns an array of word strings and an array of word starting indexes.\n * @param {string} text The original text.\n * @return {Array} A pair of arrays [array of string words, array of word starting indexes].\n */\nfunction splitTextIntoWords(text) {\n    const words = [];\n    const wordIndexes = [];\n\n    const regex = /\\S+/g; // Matches any non-whitespace sequence.\n\n    let match;\n    while ((match = regex.exec(text)) !== null) {\n        words.push(match[0]); // Gather the word string.\n        wordIndexes.push(match.index); // Gather the word starting index.\n    }\n\n    return [words, wordIndexes];\n}\n\n\n/**\n * Returns an array of positional data for each occurrence, including starting word number and ending word number.\n * @param {Array} occurrences Array of search term occurrence objects, each with 'start' and 'end' properties.\n * @param {Array} wordIndexes Array of word indexes that indicate the start position of each word in the text.\n * @param {number} contextLength The number of words to include as context on each side of the search term occurrence.\n * @return {Array} An array of occurrence position objects, each with 'start' (first word number of context)\n * and 'end' (last word number of context or null if at end of text) properties.\n */\nfunction getEachOccurrenceContextPosition(occurrences, wordIndexes, contextLength) {\n    const results = [];\n    let currentOccurrenceIndex = 0;\n\n    // Iterate through each word index\n    for (let wordNumber = 0; wordNumber < wordIndexes.length; wordNumber++) {\n        // If there are no more occurrences to check, exit the loop\n        if (currentOccurrenceIndex >= occurrences.length) {\n            break;\n        }\n\n        // Check if this is the last word\n        if (wordNumber + 1 >= wordIndexes.length) {\n            const start = Math.max(0, wordNumber - contextLength);\n            const length = null;\n            results.push({\n                start: start,\n                end: length\n            });\n            continue;\n        }\n\n        // The current occurrence to check against\n        const currentOccurrence = occurrences[currentOccurrenceIndex];\n\n        // If this word is not (yet) part of the context\n        if (wordIndexes[wordNumber + 1] <= currentOccurrence.start) {\n            continue;\n        }\n\n        // This word begins an occurrence\n        const start = Math.max(0, wordNumber - contextLength);\n        const end = getContextEnd(wordIndexes, wordNumber, currentOccurrence.end, contextLength);\n\n        const position = {\n            start: start,\n            end: end\n        };\n\n        results.push(position);\n\n        currentOccurrenceIndex++;\n    }\n\n    return results;\n}\n\n\n/**\n * Returns the number of the last word still in the context. Returns null if the context is the rest of all words.\n * @param {Array} wordIndexes An array that has the text starting index for each word.\n * @param {number} startNumber The word number where the occurrence starts.\n * @param {number} endIndex The text index where the occurrence ends.\n * @param {number} contextLength The amount of words that get returned on each side of the occurrence as context.\n * @return {?number} The word number of the last word in the context or null if it ends with the text.\n */\nfunction getContextEnd(wordIndexes, startNumber, endIndex, contextLength) {\n    for (let i = startNumber; i < wordIndexes.length; i++) {\n        // Check if the context reaches the last word\n        if (i + contextLength + 1 >= wordIndexes.length) {\n            return null;\n        }\n\n        // Check if the occurrence is part of the next word\n        if (wordIndexes[i + 1] <= endIndex) {\n            continue;\n        }\n\n        // Calculate the last word number in context\n        const lastWordInContext = i + contextLength;\n\n        return lastWordInContext;\n    }\n    return null;\n}\n\n\n/**\n * Returns an array of positional data for each occurrence set, including starting word number, ending word number, and word count.\n * @param {Array} occurrences Array of search term occurrence objects, each with 'start' and 'end' properties.\n * @param {Array} wordIndexes Array of word indexes that indicate the start position of each word in the text.\n * @param {number} contextLength The number of words to include as context on each side of the search term occurrence.\n * @return {Array} An array of occurrence position objects, each with 'start' (first word number of context)\n * and 'end' (first word number outside the context or undefined if at end of text).\n */\nfunction getContextPositions(occurrences, wordIndexes, contextLength) {\n    let occurrenceContextPositions = getEachOccurrenceContextPosition(occurrences, wordIndexes, contextLength);\n    occurrenceContextPositions = mergeOccurrenceContextPositions(occurrenceContextPositions);\n    return occurrenceContextPositions;\n}\n\n\n/**\n * Merge overlapping occurrence positions together.\n * @param {Array} contextPositions Array of position objects with 'start' (first word in context)\n * and 'end' (last word in context or null if at end of text) properties.\n * @return {Array} An array of occurrence position objects, each with 'start' (first word number of context)\n * and 'end' (first word number outside the context or undefined if at end of text).\n */\nfunction mergeOccurrenceContextPositions(contextPositions) {\n    const results = [];\n\n    for (let i = 0; i < contextPositions.length; i++) {\n        // First position.\n        let position = contextPositions[i];\n        let start = position.start;\n        let end = position.end;\n\n        // Further positions.\n        while (\n            i + 1 < contextPositions.length && // Check if there is a next position.\n            contextPositions[i].end && // Check if 'end' is null. We can then ignore all upcoming positions.\n            contextPositions[i].end >= contextPositions[i + 1].start // Check if this and the next positions overlap.\n        ) {\n            end = contextPositions[i + 1].end; // The positions overlap so the end gets set to ht next positions end.\n            i++;\n        }\n\n        const mergedPosition = {\n            start: start,\n            end: end !== null ? end + 1 : undefined // If end is not null we set end to the next element.\n        };\n\n        results.push(mergedPosition);\n\n        if (!end) { // We can ignore all later positions as we already are at the end of possible context.\n            break;\n        }\n    }\n\n    return results;\n}\n\n\n/**\n * Based on given context positions, return a combined string from a list of words.\n * @param {Array} words List of all words.\n * @param {Array} contextPositions An array of occurrence position objects, each with 'start' (first word number of context),\n * and 'end' (first word number outside the context or undefinded if at end of text)\n * @return {string} A combined string of all given positions.\n */\nfunction getContext(words, contextPositions) {\n    let context = \"... \";\n\n    contextPositions.forEach(position => {\n        const subcontextWords = words.slice(position.start, position.end);\n        context += subcontextWords.join(\" \");\n        context += \" ... \";\n    });\n\n    return context;\n}"],"names":["label","chapterLabel","document","getElementById","addEventListener","handleSearchInputChange","event","searchTerm","target","value","searchTermLabel","courseContent","JSON","parse","atob","searchResults","contextLength","results","forEach","section","context","content","searchContent","toLowerCase","indexOf","occurrenceIndexes","text","term","occurrences","termLength","length","index","offset","occurrence","start","end","push","findOccurrences","words","wordIndexes","regex","match","exec","splitTextIntoWords","contextPositions","occurrenceContextPositions","currentOccurrenceIndex","wordNumber","Math","max","currentOccurrence","position","getContextEnd","getEachOccurrenceContextPosition","i","mergedPosition","undefined","mergeOccurrenceContextPositions","getContextPositions","subcontextWords","slice","join","getContext","getSectionSearchResultContext","hasOwnProperty","filename","page","url","bookUrl","getSearchResults","innerHTML","display","pdfName","chapter","bookurl","getResultsUI","startNumber","endIndex"],"mappings":"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"}